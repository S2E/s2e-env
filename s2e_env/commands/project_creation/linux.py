"""
Copyright (c) 2017 Dependable Systems Laboratory, EPFL

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
"""


import logging
import os

from s2e_env.command import CommandError
from s2e_env.utils.elf import ELFAnalysis
from s2e_env.utils.templates import render_template
from . import BaseProject


logger = logging.getLogger('linux_project')


class LinuxProject(BaseProject):
    """
    Create a Linux project.
    """

    # User instruction templates
    S2E_SO_INSTS =                                                          \
        's2e.so\n'                                                          \
        '======\n\n'                                                        \
        '{target_path} is dynamically linked - you can use s2e.so to '      \
        'generate symbolic input'

    FUNC_MODELS_INSTS =                                                     \
        'Function Models\n'                                                 \
        '===============\n\n'                                               \
        '{target_path} is dynamically linked and imports the following '    \
        'functions that can be modelled using S2E\'s ``FunctionModels`` '   \
        'plugin:\n\n'                                                       \
        '\t{modelled_funcs}\n\n'                                            \
        'The ``FunctionModels`` plugin can be enabled in s2e-config.lua.'

    SEEDS_INSTS =                                                           \
        'Seed Files\n'                                                      \
        '==========\n\n'                                                    \
        'You have enabled seed files. This means that seed files will be '  \
        'used to drive concolic execution. Please place seeds in '          \
        '{seeds_dir}. Seed files must be named using the following '        \
        'format:\n\n'                                                       \
        '\t``<index>-<priority>.<extension>``\n\n'                          \
        'Where:\n'                                                          \
        '\t* <index> is a unique integer identifier starting from 0\n'      \
        '\t* <priority> is an integer priority, where 0 is the highest '    \
        'priorty\n'                                                         \
        '\t* <extension> an optional file extension\n'                      \
        'Examples:\n'                                                       \
        '\t0-1.png, 1-1.jpg, 2-0.elf, etc.\n\n'                             \
        'Seeds can be based on real files (e.g. a PNG image if testing a '  \
        'PNG parser), generated by a fuzzer, or randomly.'

    def __init__(self):
        super(LinuxProject, self).__init__()

        self._target_args = None
        self._dynamically_linked = False
        self._modelled_functions = []

    def handle(self, *args, **options):
        self._target_args = options['target_args']

        return super(LinuxProject, self).handle(**options)

    def _validate_binary(self, target_arch, os_name, os_arch, os_binary_formats):
        if 'elf' not in os_binary_formats:
            raise CommandError('Please use a Linux image for this binary')

        # Run default checks
        super(LinuxProject, self)._validate_binary(target_arch, os_name, os_arch, os_binary_formats)

    def _parse_target_args(self):
        """
        Parse the target program's arguments.

        The target arguments are specified using a format similar to the
        American Fuzzy Lop fuzzer. Options are specified as normal, however
        for programs that take input from a file, '@@' is used to mark the
        location in the target's command line where the input file should be
        placed. This will automatically be substituted with a symbolic file
        in the S2E bootstrap script.

        Return:
            A tuple containing:
                1. A flag that is ``True`` if a '@@' marker was found and
                   replaced with a symbolic file, or ``False`` if no such
                   marker was found
                2. A list of the new command-line arguments to render to
                   bootstrap.sh
        """
        use_symb_input_file = False
        parsed_args = []

        input_file_substitution = '${SYMB_FILE}'

        for arg in self._target_args:
            if arg == '@@':
                use_symb_input_file = True
                parsed_args.append(input_file_substitution)
            else:
                parsed_args.append(arg)

        if not use_symb_input_file:
            logger.warning('You did not specify the input file marker @@. '
                           'This marker is automatically substituted by a '
                           'file with symbolic content. You will have to '
                           'manually edit bootstrap.sh in order to run the '
                           'program on multiple paths.\n\n'
                           'Example: %s @@', self._target_path)

        if self._use_seeds and not use_symb_input_file:
            logger.warning('Seed files have been enabled, however you did not '
                           'specify an input file marker (i.e. \'@@\') to be '
                           'substituted with a seed file. This means that '
                           'seed files will be fetched but never used. Is '
                           'this intentional?')

        return use_symb_input_file, parsed_args

    def _analyze(self):
        with ELFAnalysis(self._target_path) as elf:
            self._dynamically_linked = elf.is_dynamically_linked()
            self._modelled_functions = elf.get_modelled_functions()

    def _create_bootstrap(self):
        # Parse the target's command-line arguments
        use_symb_input_file, parsed_args = self._parse_target_args()

        # Render the bootstrap script
        context = {
            'target': os.path.basename(self._target_path),
            'target_args': parsed_args,
            'use_symb_input_file': use_symb_input_file,
            'dynamically_linked': self._dynamically_linked,
            'use_seeds': self._use_seeds,
            'target_bootstrap_template': 'bootstrap.linux.sh'
        }

        output_path = os.path.join(self._project_path, 'bootstrap.sh')
        render_template(context, 'bootstrap.sh', output_path,
                        executable=True)

    def _create_config(self):
        # Render the config file
        context = {
            'project_dir': self._project_path,
            'target': os.path.basename(self._target_path),
            'function_models': len(self._modelled_functions) > 0,
            'use_seeds': self._use_seeds,
            'target_lua_template': 's2e-config.linux.lua'
        }

        for f in ('s2e-config.lua', 'models.lua', 'library.lua'):
            output_path = os.path.join(self._project_path, f)
            render_template(context, f, output_path)

    def _create_instructions(self):
        intro = 'Here are some hints to get started with your Linux project:'

        s2e_so = ''
        func_models = ''
        if self._dynamically_linked:
            s2e_so = self.S2E_SO_INSTS.format(target_path=self._target_path)

            if self._modelled_functions:
                modelled_funcs = ', '.join(self._modelled_functions)
                func_models = self.FUNC_MODELS_INSTS.format(\
                                                target_path=self._target_path,
                                                modelled_funcs=modelled_funcs)

        seeds = ''
        if self._use_seeds:
            seeds_dir = os.path.join(self._project_path, 'seeds')
            seeds = self.SEEDS_INSTS.format(seeds_dir=seeds_dir)

        # Remove empty instructions
        inst_list = [intro, s2e_so, func_models, seeds]
        return '\n\n'.join(inst for inst in inst_list if inst != '')
